# Strings

Uma [string](https://www.php.net/manual/pt_BR/language.types.string.php) é uma série de caracteres, onde um caractere é o mesmo que um byte. Isso significa que o PHP possui suporte a um conjunto de apenas 256 caracteres, e, portanto, não possui suporte nativo a Unicode. Veja mais [detalhes do tipo string](https://www.php.net/manual/pt_BR/language.types.string.php#language.types.string.details).

> **Nota**: Em sistemas de 32 bits, uma [string](https://www.php.net/manual/pt_BR/language.types.string.php) pode ter até 2GB (2147483647 bytes).

## Sintaxe

Uma [string](https://www.php.net/manual/pt_BR/language.types.string.php) literal pode ser especificada de quatro formas diferentes.

- [aspas simples](https://www.php.net/manual/pt_BR/language.types.string.php#language.types.string.syntax.single)
- [aspas duplas](https://www.php.net/manual/pt_BR/language.types.string.php#language.types.string.syntax.double)
- [sintaxe heredoc](https://www.php.net/manual/pt_BR/language.types.string.php#language.types.string.syntax.heredoc)
- [sintaxe nowdoc](https://www.php.net/manual/pt_BR/language.types.string.php#language.types.string.syntax.nowdoc)

## Aspas simples

A maneira mais simples de se especificar uma [string](https://www.php.net/manual/pt_BR/language.types.string.php) é delimitá-la entre aspas simples (o caractere ').

Para especificar um apóstrofo, escape-o com uma contrabarra (`\`). Para especificar uma contrabarra literal, duplique-a (`\\`). Todas as outras ocorrências da contrabarra serão tratadas como uma contrabarra literal: isso significa que outras sequências de escape que se esteja acostumado a utilizar, como `\r` ou `\n`, serão literalmente impressas em vez de ter qualquer significado especial.

> Nota: Diferentemente das sintaxes [com aspas duplas](https://www.php.net/manual/pt_BR/language.types.string.php#language.types.string.syntax.double) e [heredoc](https://www.php.net/manual/pt_BR/language.types.string.php#language.types.string.syntax.heredoc), [variáveis](https://www.php.net/manual/pt_BR/language.variables.php) e sequências de escape para caracteres especiais *não* serão expandidas quando ocorrerem dentro de uma [string](https://www.php.net/manual/pt_BR/language.types.string.php) delimitada por aspas simples.

```php
echo 'isto é uma string comum';

echo 'Você pode incluir novas linhas em strings,
dessa maneira que estará
tudo bem';

// Imprime: Arnold disse uma vez: "I'll be back"
echo 'Arnold disse uma vez: "I\'ll be back"';

// Imprime: Você tem certeza em apagar C:\*.*?
echo 'Você tem certeza em apagar C:\\*.*?';

// Imprime: Você tem certeza em apagar C:\*.*?
echo 'Você tem certeza em apagar C:\*.*?';

// Imprime: Isto não será substituído: \n uma nova linha
echo 'Isto não será substituído: \n uma nova linha';

// Imprime: Variáveis $também não $expandem
echo 'Variáveis $também não $expandem';
```

## Aspas duplas

Se a [string](https://www.php.net/manual/pt_BR/language.types.string.php) for delimitada entre aspas duplas ("), o PHP interpretará a seguinte sequência de escape como caracteres especiais:

|Sequências | Significado|
|---|---|
|\n |Nova linha (LF ou 0x0A (10) em ASCII)|
|\r |Retorno de carro (CR ou 0x0D (13) em ASCII)|
|\t |Tabulação horizontal (HT ou 0x09 (9) em ASCII)|
|\v |Tabulação vertical (VT ou 0x0B (11) em ASCII)|
|\e |Escape (ESC or 0x1B (27) em ASCII)|
|\f |Form feed (FF ou 0x0C (12) em ASCII)|
|\\ |contrabarra ou barra invertida|
|\$ |Sinal de cifrão|
|\" |aspas duplas|
|\[0-7]{1,3} |Octal: uma sequência de caracteres que coincide com a expressão regular [0-7]{1,3} é um caracter em notação octal (por exemplo, "\101" === "A"), o qual é silenciosamente turcado para um byte (por exemplo "\400" === "\000")|
|\x[0-9A-Fa-f]{1,2} |Hexadecimal: uma sequência de caracteres que coincide com a expressão regular [0-9A-Fa-f]{1,2} é um caracter em notação decimal (por exemplo, "\x41" === "A")|
|\u{[0-9A-Fa-f]+} |Unicode: uma sequência de caracteres coincidindo com a expressão regular [0-9A-Fa-f]+ é um codepoint Unicode, o qual terá como resultado uma string contendo a representação UTF-8 desses codepoints. Os colchetes são requeridos. Por exemplo, "\u{41}" === "A"|

Como com as [string](https://www.php.net/manual/pt_BR/language.types.string.php)s entre aspas simples, escapar qualquer outro caractere resultará em uma contrabarra sendo impressa.

O recurso mais importante de [string](https://www.php.net/manual/pt_BR/language.types.string.php)s delimitadas por aspas duplas é o fato de que nomes de variáveis serão expandidos. Veja [interpolação de strings](https://www.php.net/manual/pt_BR/language.types.string.php#language.types.string.parsing) para detalhes.

## Heredoc

Uma terceira maneira de delimitar [string](https://www.php.net/manual/pt_BR/language.types.string.php#language.types.string.parsing)s é a sintaxe heredoc: <<<. Após este operador, um identificador é fornecido seguido de uma nova linha. A própria [string](https://www.php.net/manual/pt_BR/language.types.string.php#language.types.string.parsing) é colocada em seguida e a seguir o mesmo identificador novamente para fechar a string.

O identificador de fechamento pode ser indentado com espaços ou tabulações, e nesse caso a indentação será removida de todas as linhas da doc string. Anteriormente ao PHP 7.3.0, o identificador precisava estar no começo da linha.

Além disso, o identificador de fechamento precisa seguir as mesmas convenções de nomes de outros identificadores do PHP: ele precisa conter apenas caracteres alfanuméricos e underlines, e precisa começar com uma letra ou underline.

**Exemplo #1 Exemplo Heredoc simples no PHP 7.3.0**

```php
// Sem indentação
echo <<<END
      a
     b
    c
\n
END;

// 4 espaços de indentação
echo <<<END
      a
     b
    c
    END;
```

Saída do exemplo acima no PHP 7.3:

```bash
      a
     b
    c

  a
 b
c
```

Se o identificador de fechamento estiver identado diferentemente das linhas do corpo, um [ParseError](https://www.php.net/manual/pt_BR/class.parseerror.php) será lançado:

**Exemplo #2 Identificador de fechamento indentado diferente das linhas do corpo**

```php
echo <<<END
  a
 b
c
   END;
```

Saída do exemplo acima no PHP 7.3:

```bash
PHP Parse error:  Invalid body indentation level (expecting an indentation level of at least 3) in example.php on line 4
```

Se o identificador de fechamento é identado, tabulações podem ser utilizados, no entanto tabulações e espaços não podem estar misturados ou diferentes, entre a indentação do fechamento e a indentação do corpo Nesses casos, um [ParseError](https://www.php.net/manual/pt_BR/class.parseerror.php) será lançado. Essas restrições de whitespace estão incluídas dados que a mistura de tabulações e espaços são prejudiciais à legibilidade.

```php
// Todos esses códidos falharão.

// Indentação diferente entre corpo (espaços) e fechamento (tabulações)
{
echo <<<END
a
END;
}

// Misturar tabulações e espaços no corpo
{
    echo <<<END
    a
     END;
}

// Misturar espaços e tabulações no identficador de fechamento
{
echo <<<END
a
END;
}
```

Saída do exemplo acima no PHP 7.3:

```bash
PHP Parse error:  Invalid indentation - tabs and spaces cannot be mixed in example.php line 8
```

O identificador de fechamento do corpo não necessita de um ponto e vírgula ou nova linha. Por exemplo, o seguinte código é permitido a partir do PHP7.3.0:

**Exemplo #4 Continuando uma expressão após o identificador de fechamento**

```php
$values = [<<<END
a
  b
    c
END, 'd e f'];
var_dump($values);
```

Saída do exemplo acima no PHP 7.3:

```bash
array(2) {
  [0] =>
  string(11) "a
  b
    c"
  [1] =>
  string(5) "d e f"
}
```

> **Aviso**: Se o identificador de fechamento for encontrado no começo da linha, existe a ambiguidade de ele ser considerado ou não parte do texto, podendo também ser considerado como fechamento, pode causar um [ParseError](https://www.php.net/manual/pt_BR/class.parseerror.php).
> 
> **Exemplo #5 Identificador de fechamento no corpo da string pode causar um ParseError**
> ```php
> $values = [<<<END
> a
> b
> END ING
> END, 'd e f'];
> ```
> Saída do exemplo acima no PHP 7.3:

> ```bash
> PHP Parse error:  syntax error, unexpected identifier "ING", expecting "]" in example.php on line 6
> ```
> Para evitar esse problema, basta seguir a seguinte regra: escolha identificadores que não aparecem no corpo do texto.

> **Aviso**: Anteriormente ao PHP 7.3.0, era muito importante notar que a linha com o identificador de fechamento não poderia conter outros caracteres, exceto um ponto e vírgula (;). Isso significava que o identificador de fechamento não poderia ser identado, e que não poderia haver espaços ou tabulações antes ou depois do ponto e vírgula. É importante notar também que o primeiro caractere antes do fechamento deveria ser uma newline, como definido pelo sistema operacional. Ou seja, \n em sistemas Unix, incluindo o macOS. O identificador de fechamento também deveria ser seguido de um newline.
> Se essa regra não for seguida, e o identificador de fechamento não estiver "limpo", ele não será considerado como fechamento, e o PHP continuará lendo o script como se fosse texto. Se um identificador de fechamento correto não for encontrado até o final do arquivo, um erro de interpretação será lançado na última linha.
> **Exemplo #6 Exemplo inválido, anteriormente ao PHP 7.3.0**
> ```php
> class foo {
>     public $bar = <<<EOT
> bar
>     EOT;
> }
> // O identifcador não deve ser indentado
> ```
> **Exemplo #7 Exemplo válido, mesmo antes do PHP 7.3.0**
> ```php
> class foo {
>     public $bar = <<<EOT
> bar
> EOT;
> }
> ```
> Heredocs não podem ser usados para inicializar propriedades de classe.

Textos heredoc se comportam como [string](https://www.php.net/manual/pt_BR/language.types.string.php)s delimitadas por aspas duplas, sem as aspas duplas. Isso significa que aspas simples em heredocs não precisam ser escapadas, apesar de que os códigos de escape listados acima podem continuar sendo utilizados. Variáveis são expandidas, mas o mesmo cuidado deve ser tomado ao expressar variáveis complexas dentro do heredoc assim como nas [string](https://www.php.net/manual/pt_BR/language.types.string.php)s.

**Exemplo #8 Exemplo de delimitação de strings heredoc**

```php
$str = <<<EOD
Exemplo de uma string
distribuída em várias linhas
utilizando a sintaxe heredoc.
EOD;

/* Exemplo mais complexo, com variáveis */
class foo
{
    var $foo;
    var $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'Meu nome';

echo <<<EOT
Meu nome é "$name". Eu estou imprimindo $foo->foo.
Agora, eu estou imprimindo {$foo->bar[1]}.
Isto deve imprimir um 'A' maiúsculo: \x41
EOT;
```

O exemplo acima produzirá:

```bash
Meu nome é "Meu nome". Eu estou imprimindo Foo.
Agora, eu estou imprimindo Bar2.
Isto deve imprimir um 'A' maiúsculo: A
```

É possível também utilizar a sintaxe Heredoc para passar dados para argumentos de funções:

**Exemplo #9 Exemplo de Heredoc em argumentos**

```php
var_dump(array(<<<EOD
foobar!
EOD
));
```

É possível inicializar variáveis estáticas e propriedades/constantes de classe utilizando a sintaxe heredoc:

**Exemplo #10 Utilizando o Heredoc na inicialização de valores estáticos**

```php
// Variáveis estáticas
function foo()
{
    static $bar = <<<LABEL
Nothing in here...
LABEL;
}

// Classe propriedades/constantes
class foo
{
    const BAR = <<<FOOBAR
Constant example
FOOBAR;

    public $baz = <<<FOOBAR
Property example
FOOBAR;
}
```

O identificador de abertura do Heredoc pode ser opcionalmente delimitado por aspas duplas:

**Exemplo #11 Usando aspas duplas no Heredoc**

```php
echo <<<"FOOBAR"
Hello World!
FOOBAR;
```

## Nowdoc

Nowdocs estão para aspas simples assim como os heredocs estão para aspas duplas em strings. Um nowdoc é especificado similarmente a um heredoc, mas nenhuma interpolação é feita dentro de um nowdoc. A construção é ideal para colocar códigos PHP ou outros grandes blocos de texto sem a necessidade de usar escapes. Compartilha algumas características em comum com a construção SGML <![CDATA[ ]]>, assim é declarado um bloco de texto onde nada será analisado.

Um nowdoc é identificado com a mesma sequência <<< usada para heredocs, mas o identificador precisa ficar entre aspas simples, por exemplo. <<<'EOT'. Todas as regras para identificadores heredoc também se aplicam para identificadores nowdoc, especialmente aquelas referentes a aparência do identificador de fechamento.

**Exemplo #12 Exemplo de string em Nowdoc**

```php
echo <<<'EOD'
Exemplo de string abrangendo várias linhas
usando a sintaxe nowdoc. As barras invertidas são sempre tratadas literalmente,
por exemplo. \\ e \'.
EOD;
```

O exemplo acima produzirá:

```txt
Exemplo de string abrangendo várias linhas
usando a sintaxe nowdoc. As barras invertidas são sempre tratadas literalmente,
por exemplo. \\ e \'.
```

**Exemplo #13 Exemplo de Nowdoc, com variáveis**

```php
class foo
{
    public $foo;
    public $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<'EOT'
Meu nome é "$nome". Estou imprimindo alguns $foo->foo.
Agora, estou imprimindo alguns {$foo->bar[1]}.
Isso não deve imprimir um 'A' maiúsculo: \x41
EOT;
```

O exemplo acima produzirá:

```txt
Meu nome é "$nome". Estou imprimindo alguns $foo->foo.
Agora, estou imprimindo alguns {$foo->bar[1]}.
Isso não deve imprimir um 'A' maiúsculo: \x41
```

**Exemplo #14 Exemplo de dado estático**

```php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
```

## Interpolação de strings

Quando uma string é especificada dentro de aspas duplas ou heredoc, as variáveis podem ser substituídas dentro dela.

Há dois tipos de sintaxe: uma básica e uma avançada. A sintaxe básica é a mais comum e conveniente. Provê uma maneira de incorporar uma variável, o valor de um array ou uma propriedade de object em uma string com o mínimo de esforço.

## Sintaxe básica

Se um sinal de cifrão ($) for encontrado, os caracteres que o seguem, e que podem ser usados em nome de variável, serão interpretados como tal e substituídos.

```php
$suco = "maçã";

echo "Ele bebeu um pouco de suco de $suco." . PHP_EOL;
```

O exemplo acima produzirá:

```txt
Ele bebeu um pouco de suco de maçã.
```

Formalmente, a estrutura para a sintaxe básica de substituição de variável é o seguinte:

```txt
string-variável::
     nome-de-variável   (posição-ou-propriedade)?
   | ${   expressão   }

posição-ou-propriedade::
     posição-na-string
   | propriedade-na-string

posição-na-string::
     [   nome   ]
   | [   nome-de-variável   ]
   | [   inteiro-literal   ]

propriedade-na-string::
     ->  nome

nome-de-variável::
     $   nome

nome::
     [a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*
```

> **Aviso** A sintaxe ${ expressão } tornou-se defasada a partir do PHP 8.2.0, já que pode ser interpretada como variáveis variáveis:
> ```php
> const foo = 'bar';
> $foo = 'foo';
> $bar = 'bar';
> var_dump("${foo}");
> var_dump("${(foo)}");
> ```
> 
> Saída do exemplo acima no PHP 8.2:
> 
> ```txt
> Deprecated: Using ${var} in strings is deprecated, use {$var} instead in file on line 6
> 
> Deprecated: Using ${expr} (variable variables) in strings is deprecated, use {${expr}} instead in file on line 9
> string(3) "foo"
> string(3) "bar"
> ```
> 
> O exemplo acima produzirá:
> 
> ```txt
> string(3) "foo"
> string(3) "bar"
> ```
> 
> A sintaxe avançada de interpolação de string deve ser usada em seu lugar.

> **Nota**: Se não for possível formar um nome válido, o símbolo de cifrão permanece literalmente na string:
>
> echo "Nenhuma interpolação $ aconteceu\n";
> echo "Nenhuma interpolação $\n aconteceu\n";
> echo "Nenhuma interpolação $2 aconteceu\n";
> O exemplo acima produzirá:
> 
> ```txt
> Nenhuma interpolação $ aconteceu
> Nenhuma interpolação $
>  aconteceu
> Nenhuma interpolação $2 aconteceu
> ```

**Exemplo #15 Interpolando o valor da primeira dimensão de um array ou propriedade**

```php
$sucos = array("maça", "laranja", "chave_string" => "roxo");

echo "Ele bebeu um pouco de suco de $sucos[0].";
echo PHP_EOL;
echo "Ele bebeu um pouco de suco de $sucos[1].";
echo PHP_EOL;
echo "Ele bebeu um pouco de suco de $sucos[chave_string].";
echo PHP_EOL;

class A {
    public $s = "string";
}

$o = new A();

echo "Valor do objeto: $o->s.";
```

O exemplo acima produzirá:

```txt
Ele bebeu um pouco de suco de maçã.
Ele bebeu um pouco de suco de laranja.
Ele bebeu um pouco de suco de roxo.
Valor do objeto: string.
```

> **Nota**: A chave do array deve ser sem aspas, e por isso não é possível referenciar uma constante como chave com a sintaxe básica. Use a sintaxe avançada em seu lugar.

A partir do PHP 7.1.0 índices numéricos negativos são suportados.

**Exemplo #16 Índices numéricos negativos**

```php
$string = 'string';
echo "O caractere no índice -2 é $string[-2].", PHP_EOL;
$string[-3] = 'o';
echo "Alterar o caractere no índice -3 para 'o' dá $string.", PHP_EOL;
```

O exemplo acima produzirá:

```txt
O caractere no índice -2 é n.
Alterar o caractere no índice -3 para o dá strong.
```

Para qualquer coisa mais complexa, a sintaxe avançada deve ser usada.

## Sintaxe avançada (com chaves)