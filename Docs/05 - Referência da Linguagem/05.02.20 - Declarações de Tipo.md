# Declarações de tipo

As declarações de tipo podem ser adicionadas a argumentos de função, valores de retorno, a partir do PHP 7.4.0, propriedades de classe e, a partir do PHP 8.3.0, constantes de classe. Elas garantem que o valor seja do tipo especificado no momento da chamada, caso contrário, um [TypeError](https://www.php.net/manual/pt_BR/class.typeerror.php) é lançado.

Cada tipo que o PHP suporta, com exceção de [resource](https://www.php.net/manual/pt_BR/language.types.resource.php), pode ser usado dentro de uma declaração de tipo de usuário. Esta página contém um changelog de disponibilidade dos diferentes tipos e documentação sobre o uso deles em declarações de tipo.

Nota:

Quando uma classe implementa um método de interface ou reimplementa um método já definido por uma classe pai, ela deve ser compatível com a definição acima. Um método é compatível se segue as regras de [variância](https://www.php.net/manual/pt_BR/language.oop5.variance.php).

## Registro de Alterações

| Versão | Descrição                                                                   |
| ------ | --------------------------------------------------------------------------- |
| 8.3.0  | Suporte à constantes em classes, interfaces, traits e enums foi adicionado. |
| 8.2.0  | O suporte para tipos DNF foi adicionado.                                    |
| 8.2.0  | O suporte para o tipo literal [true](https://www.php.net/manual/pt_BR/language.types.value.php) foi adicionado.                          |
| 8.2.0  | Os tipos [null](https://www.php.net/manual/pt_BR/language.types.null.php) e [false](https://www.php.net/manual/pt_BR/language.types.value.php) agora podem ser usados de forma independente.         |
| 8.1.0  | O suporte para tipos de interseção foi adicionado.                          |
| 8.1.0  | Retornar por referência de uma função [void](https://www.php.net/manual/pt_BR/language.types.void.php) agora foi descontinuado.         |
| 8.1.0  | O suporte para o tipo somente retorno [never](https://www.php.net/manual/pt_BR/language.types.never.php) foi adicionado.                 |
| 8.0.0  | O suporte para [mixed](https://www.php.net/manual/pt_BR/language.types.mixed.php) foi adicionado.                                        |
| 8.0.0  | O suporte para o tipo de retorno apenas static foi adicionado.              |
| 8.0.0  | O suporte para tipos de união foi adicionado.                               |
| 7.4.0  | Suporte para propriedades tipadas foi adicionado.                           |
| 7.2.0  | Suporte para [object](https://www.php.net/manual/pt_BR/language.types.object.php) foi adicionado.                                         |
| 7.1.0  | Suporte para [iterable](https://www.php.net/manual/pt_BR/language.types.iterable.php) foi adicionado.                                       |
| 7.1.0  | Suporte para [void](https://www.php.net/manual/pt_BR/language.types.void.php) foi adicionado.                                           |
| 7.1.0  | O suporte para tipos anuláveis foi adicionado.                              |

## Notas de uso em tipos atômicos

Os tipos atômicos têm um comportamento direto com algumas ressalvas menores que são descritas nesta seção.

### Tipos escalares

> **Aviso**: Aliases de nome para tipos escalares ([bool](https://www.php.net/manual/pt_BR/language.types.boolean.php), [int](https://www.php.net/manual/pt_BR/language.types.integer.php), [float](https://www.php.net/manual/pt_BR/language.types.float.php), [string](https://www.php.net/manual/pt_BR/language.types.string.php)) não são suportados. Em vez disso, eles são tratados como nomes de classe ou interface. Por exemplo, usar boolean como uma declaração de tipo exigirá que o valor seja uma [`instanceof`](https://www.php.net/manual/pt_BR/language.operators.type.php) da classe ou interface boolean, em vez do tipo [bool](https://www.php.net/manual/pt_BR/language.types.boolean.php):
> 
> ```php
> function test(boolean $param) {}
> test(true);
> ```
> 
> Saída do exemplo acima no PHP 8:
> 
> ```bash
> Warning: "boolean" will be interpreted as a class name. Did you mean "bool"? Write "\boolean" to suppress this warning in /in/9YrUX on line 2
> 
> Fatal error: Uncaught TypeError: test(): Argument #1 ($param) must be of type boolean, bool given, called in - on line 3 and defined in -:2
> Stack trace:
> #0 -(3): test(true)
> #1 {main}
> thrown in - on line 2
> ```

## void

> **Nota**: Retornar por referência de uma função [void](https://www.php.net/manual/pt_BR/language.types.void.php) foi descontinuado a partir do PHP 8.1.0, porque tal função é contraditória. Anteriormente, ele já emitia o seguinte [**E_NOTICE**](https://www.php.net/manual/pt_BR/errorfunc.constants.php#constant.e-notice) quando chamado: `Only variable references should be returned by reference`.
> 
> function &test(): void {}

## Tipos que podem ser chamados

Este tipo não pode ser usado como uma declaração de tipo de propriedade de classe.

> Nota: Não é possível especificar a assinatura da função.

### Declarações de tipo em parâmetros de passagem por referência

Se um parâmetro de passagem por referência tiver uma declaração de tipo, o tipo da variável é somente verificado na entrada da função, no início da chamada, mas não quando a função retorna. Isso significa que uma função pode alterar o tipo de referência de variável.

**Exemplo #1 Parâmetros de passagem por referência digitados**

```php
function array_baz(array &$param)
{
    $param = 1;
}
$var = [];
array_baz($var);
var_dump($var);
array_baz($var);
```

O exemplo acima produzirá algo semelhante a:

```bash
int(1)

Fatal error: Uncaught TypeError: array_baz(): Argument #1 ($param) must be of type array, int given, called in - on line 9 and defined in -:2
Stack trace:
#0 -(9): array_baz(1)
#1 {main}
thrown in - on line 2
```

## Notas de Uso de Tipos Compostos

As declarações de tipo composto estão sujeitas a algumas restrições e realizarão uma verificação de redundância no tempo de compilação para evitar erros simples.

> **Cuidado**: Antes do PHP 8.2.0 e da introdução dos tipos DNF, não era possível combinar tipos de interseção com tipos de união.

## Uniao de tipos